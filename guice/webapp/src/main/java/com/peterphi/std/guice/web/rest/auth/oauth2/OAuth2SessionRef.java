package com.peterphi.std.guice.web.rest.auth.oauth2;

import com.google.inject.Inject;
import com.google.inject.name.Named;
import com.peterphi.std.annotation.Doc;
import com.peterphi.std.guice.apploader.GuiceProperties;
import com.peterphi.std.guice.web.rest.jaxrs.exception.LiteralRestResponseException;
import com.peterphi.std.guice.web.rest.scoping.SessionScoped;
import com.peterphi.std.threading.Timeout;
import com.peterphi.std.types.SimpleId;
import com.peterphi.usermanager.rest.iface.oauth2server.UserManagerOAuthService;
import com.peterphi.usermanager.rest.iface.oauth2server.types.OAuth2TokenResponse;
import com.peterphi.usermanager.rest.type.UserManagerUser;
import com.peterphi.usermanager.util.UserManagerBearerToken;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.joda.time.DateTime;
import org.joda.time.Period;

import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;
import java.net.URI;
import java.util.Base64;
import java.util.concurrent.TimeUnit;

/**
 * Holds the OAuth2 callback information for this session; will start unpopulated (see {@link #isValid()}) and then be populated
 * once the OAuth2 callback completes. It will switch back to unpopulated when the OAuth2 session expires.
 * <p>
 * While populated the session ref can be used to query for the currently active <code>token</code> assigned by the server, as
 * well as querying side-channel information on the user associated with that token (when the OAuth2 provider is the User
 * Manager)
 */
@SessionScoped
public class OAuth2SessionRef
{
	private static final Logger log = LoggerFactory.getLogger(OAuth2SessionRef.class);

	public final UserManagerOAuthService authService;
	public final String oauthServiceEndpoint;

	@Inject(optional = true)
	@Doc("If specified, this value will be used instead of service.oauth2.endpoint when redirecting the client to the oauth2 server (e.g. for separate internal and external endpoints)")
	@Named("service.oauth2.redirect-endpoint")
	public String oauthServiceRedirectEndpoint;

	@Inject(optional = true)
	@Doc("If specified, this value will be used instead of local endpoint when telling the oauth2 server where to send the oauth2 reply (e.g. to allow a relative response). Will have the following added to it: /oauth2/client/cb")
	@Named("service.oauth2.self-endpoint")
	public String oauthSelfEndpoint;

	@Inject(optional = true)
	@Named("token-refresh.refresh-before-expire")
	@Doc("The amount of time prior to the server-declared expiry when the OAuth token will be refreshed; this protects against  (default PT5M)")
	public Period tokenRefreshPriorToExpire = Period.parse("PT5M");

	@Inject(optional = true)
	@Doc("The duration for any delegated tokens generated by this service (default 1h)")
	@Named("token-delegation.validity-period")
	public Timeout delegatedTokenValidityPeriod = new Timeout(1, TimeUnit.HOURS);

	@Inject(optional = true)
	@Doc("The amount of time after which a delegation token will be regenerated; the difference between this value and the validity period should be the maximum duration of a service call, otherwise the credentials may expire during an operation (default 45m)")
	@Named("token-delegation.refresh-period")
	public Timeout delegatedTokenRefreshPeriod = new Timeout(45, TimeUnit.MINUTES);

	@Inject(optional = true)
	@Doc("If true, allows the generation of a Delegated Token so that user info and role data can be passed to other services as part of a service call (default true)")
	@Named("token-delegation.enabled")
	public boolean allowDelegatedTokenGeneration = true;

	private final URI localEndpoint;

	/**
	 * A nonce value used to make sure that authorisation flows originated from this session ref
	 */
	private final String callbackNonce = SimpleId.alphanumeric(20);

	public final String clientId;
	private final String clientSecret;

	private OAuth2TokenResponse response;
	private UserManagerUser cachedInfo;

	private OAuth2DelegatedToken delegatedToken;


	@Inject
	public OAuth2SessionRef(final UserManagerOAuthService authService,
	                        @Named("service.oauth2.endpoint") final String oauthServiceEndpoint,
	                        @Named("service.oauth2.client_id") final String clientId,
	                        @Named("service.oauth2.client_secret") final String clientSecret,
	                        @Named(GuiceProperties.LOCAL_REST_SERVICES_ENDPOINT) URI localEndpoint)
	{
		this.authService = authService;
		this.oauthServiceEndpoint = oauthServiceEndpoint;
		this.clientId = clientId;
		this.clientSecret = clientSecret;
		this.localEndpoint = localEndpoint;

		log.trace("OAuth2SessionRef::new");
	}


	public synchronized boolean hasBeenInitialised()
	{
		return (response != null);
	}


	/**
	 * Initialise this session reference by exchanging an API token for an access_token and refresh_token
	 *
	 * @param token
	 */
	public synchronized void initialiseFromAPIToken(final String token)
	{
		final String responseStr = authService.getToken(UserManagerOAuthService.GRANT_TYPE_TOKEN_EXCHANGE,
		                                                null,
		                                                getOwnCallbackUri().toString(),
		                                                clientId,
		                                                clientSecret,
		                                                null,
		                                                null,
		                                                null,
		                                                token,
		                                                null);

		loadAuthResponse(responseStr);
	}


	public synchronized boolean isValid()
	{
		if (response == null)
		{
			log.trace("OAuth2SessionRef - isNotValid (no recheck needed)");
			return false; // Cannot be valid because there is no response data available at all
		}

		try
		{
			getToken();
		}
		catch (Throwable e)
		{
			if (log.isTraceEnabled())
				log.trace("isValid encountered exception calling getToken: {}", e.getMessage(), e);
			// otherwise ignore
		}

		if (response == null)
			log.trace("OAuth2SessionRef - isNotValid");

		return response != null;
	}


	/**
	 * Return the URI for this service's callback resource
	 *
	 * @return
	 */
	public URI getOwnCallbackUri()
	{
		String localEndpointStr = (oauthSelfEndpoint != null) ? oauthSelfEndpoint : localEndpoint.toString();

		if (!localEndpointStr.endsWith("/"))
			localEndpointStr += "/";

		return URI.create(localEndpointStr + "oauth2/client/cb");
	}


	/**
	 * Get the endpoint to redirect a client to in order to start an OAuth2 Authorisation Flow
	 *
	 * @param returnTo The URI to redirect the user back to once the authorisation flow completes successfully. If not specified
	 *                 then the user will be directed to the root of this webapp.
	 * @return
	 */
	public URI getAuthFlowStartEndpoint(final String returnTo, final String scope)
	{
		final String oauthServiceRoot = (oauthServiceRedirectEndpoint != null) ?
		                                oauthServiceRedirectEndpoint :
		                                oauthServiceEndpoint;
		final String endpoint = oauthServiceRoot + "/oauth2/authorize";

		UriBuilder builder = UriBuilder.fromUri(endpoint);

		builder.replaceQueryParam("response_type", "code");
		builder.replaceQueryParam("client_id", clientId);
		builder.replaceQueryParam("redirect_uri", getOwnCallbackUri());
		if (scope != null)
			builder.replaceQueryParam("scope", scope);

		if (returnTo != null)
			builder.replaceQueryParam("state", encodeState(callbackNonce + " GET " + returnTo));

		return builder.build();
	}


	/**
	 * Encode the state value into RFC $648 URL-safe base64.
	 *
	 * @param src Should be of the form <code>nonce [http request] [redirect url]</code>
	 * @return
	 */
	private String encodeState(final String src)
	{
		return Base64.getUrlEncoder().encodeToString(src.getBytes());
	}


	/**
	 * Decode the state value (which should be encoded as RFC 4648 URL-safe base64)<br /> The state should be encoded as:
	 * <code>nonce [http request] [redirect url]</code>.
	 *
	 * @param src
	 * @return
	 * @see #encodeState(String)
	 */
	private static String decodeState(final String src)
	{
		return new String(Base64.getUrlDecoder().decode(src));
	}


	/**
	 * Decode the state to retrieve the redirectTo value
	 *
	 * @param state
	 * @return
	 */
	public URI getRedirectToFromState(final String state)
	{
		final String[] pieces = decodeState(state).split(" ", 3);

		if (!StringUtils.equals(callbackNonce, pieces[0]))
		{
			// The callback nonce is not what we expect; this is usually caused by:
			// - The user has followed a previous oauth callback entry from their history
			// - The user has accessed a service via a non-canonical endpoint and been redirected by the oauth server to the canonical one
			//   which means the original nonce stored in the session is not available to this session.

			// To get around this, we simply redirect the user to the root of this service so they can start the oauth flow again
			throw new LiteralRestResponseException(Response.seeOther(URI.create("/")).build());
		}

		if (pieces.length >= 2)
		{
			return getRedirectToFromStateIgnoringNonce(state);
		}
		else
		{
			return null;
		}
	}


	/**
	 * Gets the URI the user should GET for the redirect. N.B. fails on anything other than GET.
	 *
	 * @param state
	 * @return
	 */
	public static URI getRedirectToFromStateIgnoringNonce(final String state)
	{
		final String[] pieces = decodeState(state).split(" ", 3);

		if (!StringUtils.equals("GET", pieces[1]))
			throw new IllegalArgumentException("WARNING: Unsupported redirect type (expected GET)");

		return URI.create(pieces[2]);
	}


	public synchronized boolean shouldRefresh()
	{
		return response != null && (response.refresh != null && System.currentTimeMillis() > response.refresh.getTime());
	}


	public synchronized String getToken()
	{
		if (response == null)
			throw new IllegalArgumentException("Not loaded yet!");

		// If the token has expired then we must use the refresh token to refresh it
		if (shouldRefresh())
		{
			if (response != null &&
			    response.refresh_token == null &&
			    UserManagerBearerToken.isUserManagerDelegatedBearer(response.access_token))
				throw new IllegalArgumentException("Delegated Bearer Token used to make this service call has expired.");
			else if (log.isDebugEnabled())
				log.debug("OAuth token has expired for {} and must be refreshed",
				          (cachedInfo != null) ?
				          cachedInfo.email :
				          "OAuth session refresh=" + (response != null ? response.refresh_token : null));

			// Will throw an exception if the token acquisition fails
			refreshToken();
		}

		if (this.response != null && this.response.access_token != null)
			return this.response.access_token;
		else
			throw new IllegalArgumentException("Could not acquire token!");
	}


	/**
	 * Use the refresh token to get a new token with a longer lifespan
	 */
	public synchronized void refreshToken()
	{
		final String refreshToken = this.response.refresh_token;

		if (refreshToken == null)
			throw new IllegalArgumentException("Refresh Token not present, reauthentication required");

		this.response = null;
		clearUserInfo();

		final String responseStr = authService.getToken(UserManagerOAuthService.GRANT_TYPE_REFRESH_TOKEN,
		                                                null,
		                                                null,
		                                                clientId,
		                                                clientSecret,
		                                                refreshToken,
		                                                null,
		                                                null,
		                                                null,
		                                                null);

		loadAuthResponse(responseStr);
	}


	protected synchronized void loadAuthResponse(final String responseStr)
	{
		final OAuth2TokenResponse response = OAuth2TokenResponse.decode(responseStr);

		load(response);
	}


	public synchronized void refreshUserInfo()
	{
		clearUserInfo();

		this.cachedInfo = authService.get(getToken(), clientId);
	}


	private synchronized void clearUserInfo()
	{
		log.trace("OAuth2SessionRef::clearUserInfo");

		this.cachedInfo = null;

		// Clear the delegated token too
		this.delegatedToken = null;
	}


	public synchronized UserManagerUser getUserInfo()
	{
		if (!isValid())
			throw new IllegalArgumentException("No OAuth2 session information!");

		// Make sure we refresh the token if necessary (also makes sure we invalidate the user info cache if necessary
		getToken();

		if (this.cachedInfo == null)
		{
			refreshUserInfo();
		}

		return this.cachedInfo;
	}


	public synchronized void load(final OAuth2TokenResponse response)
	{
		clearUserInfo();

		if (StringUtils.isNotBlank(response.error))
		{
			throw new IllegalArgumentException("OAuth2 token acquisition failed with error: " + response.error);
		}
		else
		{
			this.response = response;

			// If the response contains a refresh token but no refresh time, create one based on the expires time
			if (this.response.expires != null && this.response.refresh == null && response.refresh_token != null)
				this.response.refresh = new DateTime(this.response.expires).minus(tokenRefreshPriorToExpire).toDate();

             // Proactively obtain user information
             refreshUserInfo();
		}
	}


	public synchronized String getOrCreateDelegatedToken()
	{
		if (!allowDelegatedTokenGeneration)
			throw new IllegalArgumentException("Delegated Token generation has been prohibited within this service!");

		final UserManagerUser info = getUserInfo();

		if (info.delegated)
		{
			// Already have a delegated token, use that directly
			return getToken();
		}
		else if (delegatedToken == null || delegatedToken.getExpires() <= System.currentTimeMillis())
		{
			delegatedToken = generateNewDelegatedToken();
		}

		return delegatedToken.getValue();
	}


	/**
	 * Generates a new OAuth2 Delegated Token
	 *
	 * @return
	 */
	private OAuth2DelegatedToken generateNewDelegatedToken()
	{
		// Check that the user session is still valid
		if (!isValid())
			throw new IllegalArgumentException("Failed to generate delegated token: user session no longer valid!");

		log.trace("OAuth2SessionRef::generateNewDelegatedToken");

		final long refreshAfter = System.currentTimeMillis() + delegatedTokenRefreshPeriod.getMilliseconds();

		// Create a new delegation token
		return new OAuth2DelegatedToken(authService.createDelegatedAccessToken(clientId,
		                                                                       clientSecret,
		                                                                       delegatedTokenValidityPeriod.getMilliseconds(),
		                                                                       this.response.refresh_token,
		                                                                       null), refreshAfter);
	}
}
